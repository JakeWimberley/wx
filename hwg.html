<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
	<link href="https://fonts.googleapis.com/css?family=Kanit" rel="stylesheet">
	<link href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.3.1/leaflet.css" rel="stylesheet">
	<style>
	#controlContainer {
		margin-bottom: 20px;
	}
	#llPicker {
		height: 270px;
		width: 480px;
		display: inline-block;
	}
	#graph, #topTitle, #bottomTitle {
		background-color: lightskyblue;
	}
	#topTitle, #bottomTitle {
		color: linen;
		font-family: 'Kanit', sans-serif;
		padding: 5px;
	}
	#bottomTitle { /* workaround for mysterious gap below SVG */
		position: relative;
		top: -5px;
	}
	#placeName {
		font-size: 24px;
	}
	#elementName {
		padding-right: 50px;
	}
	#timeRangeDesc {
		font-style: italic;
	}
	#graph polygon {
		fill: linen;
	}
	#graph text {
		font: 10px sans-serif;
		text-anchor: end;
	}
	.xAxis line, .xAxis path {
		stroke: linen;
	}
	.xAxis text {
		fill: linen;
	}
	.sameWidthAsGraph {
		margin: 0px;
	}
	#footer {
		font-size: 10px;
	}
	</style>
	<script src="https://code.jquery.com/jquery-3.3.1.js"></script>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="https://momentjs.com/downloads/moment.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.3.1/leaflet.js"></script>
	<script>
	var currentFcst = {};
	var currentLL = {};
	currentLL.latlng = { lat: 35, lng: -82 }; // default location
	var mapPicker;
	var graphDimensions = { width: 1600*0.75, height: 900*0.65, easementTimeAxis: 20, gapTimeAxis: 3 };
	var daysOfWeek = ['Su','Mo','Tu','We','Th','Fr','Sa'];
	var elementChoices = {
		'temperature': 'Temperature',
		'dewpoint': 'Dewpoint',
		'relativeHumidity': 'Relative Humidity',
		'apparentTemperature': 'Apparent Temperature',
		'skyCover': 'Sky Cover',
		'windSpeed': 'Wind Speed',
		'windGust': 'Wind Gust',
		'probabilityOfPrecipitation': 'Chance of Precipitation',
	};
	function ParsePeriod(v) {
		// v is a string in ISO 8601 duration format
		var s = v.split('/');
		var startTime = moment(s[0]);
		var endTime = moment(s[0]).add(moment.duration(s[1]));
		return [startTime.toDate(),endTime.toDate()];
	}
	function DrawForecast(f,e,tr) {
		console.log('drawing forecast of element ' + e + ' for ' + f.locationName);
		/*
			f: forecast object as generated by ForecastForLatLon()
			e: wx element name as given in JSON e.g. https://api.weather.gov/gridpoints/GSP/77,50
			tr: optional time range [Date(),Date()]
			    if not specified, defaults to full range of data
		*/
		// allValidPeriods is a list comprised of [startDate,endDate] values for each timestep.
		var allValidPeriods = f.wx[e].values.map(i => ParsePeriod(i.validTime));
		// elementValues is the list of meteorological values only.
		var elementValues = f.wx[e].values.map(i => i.value);
		var ScaleBarHeight = d3.scaleLinear().domain([d3.min(elementValues), d3.max(elementValues)]).range([1,graphDimensions.height]);
		var fullTimeRange = ParsePeriod(f.validRange);
		var displayTimeRange = tr ? tr : fullTimeRange;
		var ScaleBarWidth = d3.scaleTime().domain(displayTimeRange).range([10,graphDimensions.width-10]);
		var timeRangeDescription = 'from ' + moment(displayTimeRange[0]).calendar() + ' to ' + moment(displayTimeRange[1]).calendar();
		d3.select("#officeName").text(f.officeName);
		d3.select("#placeName").text(f.locationName);
		d3.select("#elementName").text(elementChoices[e]);
		d3.select("#timeRangeDesc").text(timeRangeDescription);		
		d3.select("#gridpointUrl").attr("href", f.gridpointUrl).text('View raw data for ' + f.locationName);
		var graph = d3.select("#graph")
			.attr("width", graphDimensions.width)
			.attr("height", graphDimensions.height + graphDimensions.easementTimeAxis);
		graph.append("g")
			.attr("class", "xAxis")
			.attr("transform", "translate(0," + (graphDimensions.height + graphDimensions.gapTimeAxis) + ")");
		d3.select("#imageContainer").attr("style", "width: " + graphDimensions.width + "px");
		var bars = graph.selectAll("polygon")
			.data(f.wx[e].values)
			.attr("points", function(d,i) { var attr = ScaleBarWidth(allValidPeriods[i][0]) + ',' + graphDimensions.height + ' '
									 + (ScaleBarWidth(allValidPeriods[i][1]) - 1) + ',' + graphDimensions.height + ' '
									 + (ScaleBarWidth(allValidPeriods[i][1]) - 1) + ',' + (graphDimensions.height - ScaleBarHeight(d.value)) + ' '
									 + ScaleBarWidth(allValidPeriods[i][0]) + ',' + (graphDimensions.height - ScaleBarHeight(d.value)); 
								return attr; } );
		bars.exit().remove();
		bars.enter().append("polygon")
			.attr("points", function(d,i) { var attr = ScaleBarWidth(allValidPeriods[i][0]) + ',' + graphDimensions.height + ' '
									 + (ScaleBarWidth(allValidPeriods[i][1]) - 1) + ',' + graphDimensions.height + ' '
									 + (ScaleBarWidth(allValidPeriods[i][1]) - 1) + ',' + (graphDimensions.height - ScaleBarHeight(d.value)) + ' '
									 + ScaleBarWidth(allValidPeriods[i][0]) + ',' + (graphDimensions.height - ScaleBarHeight(d.value)); 
								return attr; } );
		var timeAxis = d3.axisBottom(ScaleBarWidth).tickPadding(1);
		//var timeAxis = d3.axisBottom(ScaleBarWidth).tickFormat(d3.timeFormat("%a")).tickPadding(1);
		d3.selectAll("g.xAxis")
			.call(timeAxis)
			.selectAll("text")
			.attr("y", 3)
			.attr("x", 3)
			.style("text-anchor","start");
	}
	function ForecastForLatLon(lat,lon,e) {
		var fcst = {};
		$.getJSON(
			'https://api.weather.gov/points/' + lat + ',' + lon,
			function(response) {
				fcst.officeMetadataUrl = response.properties.forecastOffice;
				$.getJSON( // guess this is async and prone to race condition, but it seems to work
					fcst.officeMetadataUrl,
					function(r) {
						fcst.officeName = r.name;
					}
				);
				fcst.gridpointUrl = response.properties.forecastGridData;
				$.getJSON(
					fcst.gridpointUrl,
					function(response2) {
						fcst.wx = response2.properties;
						fcst.validRange = response2.properties.validTimes;
						//console.log(response.properties.cwa,response.properties.gridX,response.properties.gridY);
						fcst.gridX = response.properties.gridX;
						fcst.gridY = response.properties.gridY;
						fcst.cwa = response.properties.cwa;
						fcst.locationName = response.properties.relativeLocation.properties.city + ', ' + response.properties.relativeLocation.properties.state;
						DrawForecast(fcst,"temperature");
					}
				);
			}
		);
		return fcst;
	}
	function ForecastForCurrentLL() {
		console.log('retreiving new fcst for current LL: ' + currentLL.latlng.lat, currentLL.latlng.lng);
		return ForecastForLatLon(currentLL.latlng.lat,currentLL.latlng.lng);
	}
	</script>
</head>

<h2>Hourly Weather Grapher</h2>
<div id="controlContainer">
<div id="llPicker"></div> <select id="queryElement"></select>
</div>
<div id="imageContainer">
<p id="topTitle" class="sameWidthAsGraph"><span id="placeName">Click a location on the map first</span><br><span id="elementName">Then choose a wx element</span><span id="timeRangeDesc">And a time range</span></p>
<svg id="graph"></svg><p id="bottomTitle" class="sameWidthAsGraph">National Weather Service - <span id="officeName">Local Forecast Office</span></p>
</div>
<p id="footer">A Jake Wimberley Production. <a id="gridpointUrl" href="#">Huh?</a></p>

<script>
function getLLFromClick(e) {
	console.log('click at ' + e.latlng);
	currentLL.latlng = { lat: e.latlng.lat, lng: e.latlng.lng };
	if (currentLL.marker) currentLL.marker.remove();
	currentLL.marker = L.marker(currentLL.latlng).addTo(mapPicker);
	$("#queryElement").val("temperature");
	currentFcst = ForecastForCurrentLL();
}

$(function() {
	var qE = $("#queryElement");
	mapPicker = L.map('llPicker').setView([currentLL.latlng.lat,currentLL.latlng.lng], 8);
	L.tileLayer('https://a.tile.opentopomap.org/{z}/{x}/{y}.png', {
		attribution: 'opentopomap.org, CC-BY-SA',
		maxZoom: 17,
	}).addTo(mapPicker);
	mapPicker.on('click', getLLFromClick);
	//ForecastForCurrentLL();
	$.each(elementChoices, function(e) { qE.append($("<option />").val(e).text(elementChoices[e])); });
	qE.change(function() { console.log(qE.val()); DrawForecast(currentFcst,qE.val()); } );
});
</script>
